# 4장 설계 품질과 트레이드오프

결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙이 있다. 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것이다. 객체를 단순한 데이터의 집합으로 바라보는 시각은 객체의 내부 구현을 퍼블릭 인터페이스에 노출시키는 결과를 낳기 때문에, 결과적으로 설계가 변경에 취약해진다.

이 장은 데이터 중심의 영화 예매 시스템을 만들어 보는 과정을 살펴보며, 어떤 점에서 책임 중심의 객체 지향 설계보다 좋지 않은지 이야기한다.

# 1 데이터 중심의 영화 예매 시스템

- 객체의 상태는 구현에 속한다.

# 2 설계 트레이드오프

## 캡슐화

- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서이다.
여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다.
- 객체지향 프로그래밍을 통해 전반적으로 얻을 수 있는 장점은 오직 설계 과정 동안 캡슐화를 목표로 인식할 때만 달성될 수 있다.
- **변경될 수 있는 어떤 것이라도 캡슐화해야 한다.**

## 응집도와 결합도

- 응집도 : 내부 요소들이 연관돼 있는 정도
    - 변경 발생 시, 모듈 내부에서 발생하는 변경의 척도. 변경 수용 위해 모듈 전체 변경되면, 응집도 높은 것!
- 결합도 : 의존성의 정도를 나타내며, 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타낸다.
    - 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도

# 3 데이터 중심의 영화 예매 시스템의 문제점

## 1)캡슐화 위반

협력에 관해 고민하지 않음 → 과도한 접근자와 수정자 → 내부 상태를 드러내는 메서드

cf. 추측에 의한 설계 전략 

## 2)높은 결합도

하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다.

전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 어떤 변경이라도 일단 발생하고 나면 시스템 전체가 요동칠 수 밖에 없다.

## 3)낮은 응집도

- 변경과 아무 상관 없는 코드들이 영향을 받는다.
- 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈 수정해야 한다.

# 4 자율적인 객체를 향해

## 캡슐화를 지켜라

접근자와 수정자를 통해 속성을 외부로 제공한다면 캡슐화 위반!

## 스스로 자신의 데이터를 책임지는 객체

'이 객체가 어떤 데이터를 포함해야 하는가?' 라는 질문은 다음 두 가지로 분리되어야 한다.

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 **수행해야 하는 오퍼레이션**은 무엇인가?

# 5 하지만 여전히 부족하다

## 캡슐화 위반

1) 시그니처를 총해 객체 내부 상태를 드러내었다.

isDiscountable(DayOfWeek .., LocalTime time) {..}, isDiscountable(int sequence)...

2) 메서드가 정책을 다 드러냈다.

calculateAmountDiscountedFee() {}..

calculatePercentDiscountedFee() {}..

calculateNoneDiscountedFee() {}..

## 높은 결합도

DiscountCondition 구현 변경 → Movie 영향

DiscountCondition의 내부 구현을 제대로 캡슐화하지 못했기 때문

## 낮은 응집도

하나의 변경을 수용하기 위해 코드의 여러 곳을 동시 변경해야 한다.

# 6 데이터 중심 설계의 문제점

단점 두 가지

- 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 데이터 중심의 설계는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

---

# 인상 깊었던 점

1 데이터는 구현의 일부다!

2 데이터에 관한 지식이 객체 인터페이스에 고스란히 드러나면, 캡슐화 실패!

3 데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부로 향하는, 바람직하지 않은 설계다!