# 10장 상속과 코드 재사용

이 장에서 말하고 싶은 것 간략히 요약하면...

- 객체지향 프로그래밍의 장점인 재사용의 방법인 **상속의 장단점을 살펴보기!**

# 1 상속과 중복 코드

- DRY 원칙 : Don't Repeat Yourself
동일한 지식을 중복하지 말라!

(이하부터는 중복 코드를 추가해보고, 상속으로 구현하고 여기서 점차 추상화하는 과정으로 전개한다.
상황 :일반 주간 요금제 Phone을 상속하는 야간 할인 요금제 NightlyDiscountPhone이 추가되었다.)

## 중복과 변경

- 중복 코드가 존재하는 경우, 두 클래스를 함께 수정해야 한다.
- 중복 코드는 항상 함께 수정돼야 하기 때문에 수정할 때 하나라도 빠트린다면 버그로 이어질 것이다.
- 중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은 새로운 중복 코드를 추가하는 것 뿐이다.

## 상속을 이용해서 중복 코드 제거하기

### 상속을 위한 경고1

자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다.

- Phone에서는 기본 요금제로 calculateFee가 계산되고, 이를 상속하는 NightlyDiscountPhone에서는 super.calculateFee(); 호출 후 할인 금액만큼 차감한다고 해보자. 이는 상위 클래스의 변화에 강하게 결합되며, 요구사항과 구현 사이의 차이가 커지면서 이해하기도 어렵다.

# 2 취약한 기반 클래스 문제

부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 **취약한 기반 클래스 문제** 라고 한다.

- 상속은 자식 클래스가 부모 클래스의 구현 세부 사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.
- 객체지향의 기반은 캡슐화를 통한 변경의 통제다.

## 불필요한 인터페이스 상속 문제

예시

- Stack이 Vector 상속하는 경우 : push, pop 이외로 add, remove를 갖는다. 따라서 기대하는 Stack의 규칙을 무너뜨린다.
- Properties가 Hashtable 상속하는 경우 : Hashtable의 put을 사용할 수 있다. 본래 Properties는 String, String 형태의 key, value를 갖는데, 상위 클래스의 메소드를 허용하면서 규칙이 무너진다.

→ 객체 지향의 핵심은 객체들의 협력이다. 단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안된다.

### 상속을 위한 경고2

상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴 수 있다.

## 메서드 오버라이딩의 오작용 문제

예시

- InstrumentedHashSet은 HashSet을 상속한다. 이 자식 클래스의 add, addAll 오버라이딩한다고 해보자. 오버라이딩하는 addAll에서 단순히 멤버 변수의 element 개수만 더해주고, super.addAll(c)을 했다고 하자.
    - 부작용이 발생하는데, 부모 클래스인 HashSet에서 add 를 내부적으로 호출하는 것이다.
    InstrumentedHashSetdml add에서도 카운트만 더하고 super.add(e);를 했다고 하면, 전체 카운트는 예상보다 2배가 될 것이다.

### 상속을 위한 경고3

자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

→ 대안

같은 클래스의 다른 메서드를 호출하는지에 대해 반드시 문서화해야 한다. 서브 클래스가 안전할 수 있게끔 문서화하려면 클래스의 상세 구현 내역을 기술해야 한다. 
; 상속이 캡슐화를 위반하게 됨으로써, API문서가 어떻게 하는지를 설명해야하는 불상사! ㅜ

## 부모 클래스와 자식 클래스의 동시 수정 문제

예시

노래 목록을 의미하는 Playlist가 있고, 사용자가 이 목록에서 개별적으로 노래를 제거할 수 있는 PersonalPlayList가 있다고 하자(Playlist를 상속하며, remove 메서드 별도 존재). 만약 여기서 가수 이름 - 가수 노래 로 저장하는 key value map이 생겼다고 하자. Playlist에서 노래 append시 이 map은 업데이트하도록 수정했다고 하자. 그런데 자식 클래스 PersonalPlayList에서 remove를 할 때도 저 map을 수정하는 사항이 추가 구현되어야한다.

# 3 Phone 다시 살펴보기

## 추상화에 의존하자

자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 하자!

## 차이를 메서드로 추출하라

- "변하는 것으로부터 변하지 않는 것을 분리하라"
- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하자.

## 중복 코드를 부모 클래스로 올려라

cf. 중복 혹은 공통코드를 메서드로 먼저 옮기고, 그 다음에 인스턴스 변수를 옮기면 필요한 것만 잘 옮길 수 있다!
(필요한 변수 없을시 컴파일 에러로 잡아준다)

    public abstract class AbstractPhone {
    	private List<Call> calls = new ArrayList<>();
    
    	public Money calculateFee() {  // 사실 final 붙여도 된다
    		Money result = Money.ZERO;
    
    		for (Call call : calls) {
    			result = result.plut(calculateCallFee(call));
    		}
    
    		return result;
    	}
    
    	abstract protected Money calculateCallFee(Call call);
    }

## 추상화가 핵심이다

위에서, 부모 클래스 역시 자신의 내부에 구현된 추상 메서드를 호출하기 때문에 추상화에 의존한다고 말할 수 있다. 의존성 역전 원칙도 준수하는데, 요금 계산과 관련된 상위 수준의 정책을 구현하는 AbstractPhone이 세부적인 요금 계산 로직을 구현하는 Phone과 NightlyDiscountPhone에 의존하지 않고 그 반대로 Phone과 NightlyDiscountPhone이 추상화인 AbstractPhone에 의존하기 때문이다.

## 의도를 드러내는 이름 선택하기

## 세금 추가하기(기능 수정시 여파 -인스턴스 변수 추가 영향)

요금을 계산하는 것에 더불어, 세금도 추가된다고 해보자. 그러면 Phone 뿐만 아니라 NightlyDiscountPhone의 생성자에서도 코드 수정이 생긴다.

; 부모 클래스에 추가된 인스턴스 변수는 자식 변수의 초기화 로직에 영향을 미치게 된다. 결과적으로 아무리 책임을 잘 분리하더라도 인스턴스 변수의 추가는 종종 상속 계층 전반에 걸친 변경을 유발한다.

- 메서드 구현에 대한 결합은 추상 메서드를 추가함으로써 어느 정도 완화할 수 있지만 인스턴스 변수에 대한 잠재적인 결합을 제거할 수 있는 방법은 없다.

# 4 차이에 의한 프로그래밍

Programming by difference.

- 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법
- 차이에 의한 프로그래밍의 목표는 중복 코드를 제거하고 코드를 재사용하는 것이다.

상속은 강력한 만큼 잘못 사용할 경우 돌아오는 피해 역시 크다. 좋은 재사용 방법은 합성이다! (다음 챕터)