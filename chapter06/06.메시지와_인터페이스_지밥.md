## 메시지와 인터페이스

#### 01. 클라이언트 - 서버 모델
메시지 : 객체 간의 협력을 가능하게 하는 매개체. 우리는 대화해야만 서로 커뮤니케이션 할 수 있다.

전통적인 메타포가 클라이언트 - 서버 모델이다.
메시지를 전송하는 객체 : 클라이언트
매세지를 수신하는 객체 : 서버

**객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행할 수 있다.**

협력의 관점에서의 객체는 두가지의 메시지 집합으로 이루어져 있다.
1. 객체가 수신하는 메시지의 집합
2. 외부의 객체에게 전송하는 메시지의 집합

---

##### 메시지 전송

condition.isSatisfiedBy(screening)

condition아 너 screening에 만족하니?

* condition : 수신자
* isSatisfiedBy(screening) : 메시지
* condition.isSatisfiedBy(screening) : 메시지 전송

---

##### 메시지와 메서드

메시지를 수신했을 때 어떤 코드가 실행될까?
그것은 메시지 수신자의 실제 타입에 따라 달라진다.

이처럼 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 **메서드** 라고 부른다.

condition이 PeriodCondition의 인스턴스라면 PeriodCondition에 구현된 isSatisfiedBy 메서드가 실행될 것이고, condition이 SequenceCondition의 인스턴스라면 SequenceCondition에 구현된 isSatisfiedBy가 실행될 것

---

##### 퍼블릭 인터페이스와 오퍼레이션

퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 집합

오퍼레이션 : 퍼블릭인터페이스에 포함된 메시지, 흔히 내부 구현코드는 제외하고 단순히 메시지 관련 시그니처를 의미함. (주의 : 실제 실행되는 것은 메서드)


하나의 오퍼레이션에 하나의 메서드만 존재한다면 두가지를 구분할 필요가 없다.
하지만 다형성의 축복!을 받기 위해서는 하나의 오퍼레이션에 다양한 메서드를 구현해야 함.

---

### 02. 인터페이스와 설계 품질

좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스 라는 조건을 만족해야한다.

의존성을 높이지 않기 위해 제안된 원칙 **디미터의 법칙** 을 사용하면 객체간의 협력 경로를 제한할 수 있다.

> only talk to your immediate neighbors

> use only one dot

디미터의 법칙을 이용하면 부끄럼타는 코드(필요한 어떤 것도 다른 객체에게 보여주지 않고, 다른 객체 구현에 의존하지 않는 코드)를 만들 수 있다.

##### 묻지말고 시켜라

> Tell don't ask

내부에 접근하는 대신 시켜라 !

하지만 단순하게 객체에게 묻지않고 시킨다고 해서 문제가 해결되는 것은 아님.

훌륭한 인터페이스를 수확하기 위해서는 객체가 어떻게 작업을 수행하는지를 노출해서는 안된다, 인터페이스는 객체가 어떻게 하는지가 아니라 **무엇을** 하는지를 서술해야 한다.


#### 의도를 드러내는 인터페이스

1) 첫번째 방법 : 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다.

2) 두번째 방법 : '어떻게'가 아니라 **'무엇을'** 하는지를 드러내는 것

            어떻게 -> 메서드의 내부 구현을 설명하는 이름.
            ex) isSatisfiedByPeriod
                isSatisfiedBySequence

            무엇을 -> 클라이언트 관점에서 두 메서드는 할인 여부를 판단
            ex) isSatisfiedBy


이 때, 클라이언트가 두 메서드를 가진 객체를 동일한 타입으로 간주할 수 있도록 동일한 타입 계층으로 묶어야 한다. 가장 간단한 방법은 퍼블릭 인터페이스를 정의하고 이 인터페이스에 isSatisfiedBy 오퍼레이션을 정의하는 것. 이 인터페이스를 implements(실체화)하면 클라이언트 입장에서 두 메서드를 동일한 방식으로 사용할 수 있다.


명명의 중요성을 깨달았고~~, 의도를 드러내는 인터페이스의 원칙으로 더 간결한 코드를 만들 수 있을 것이다~~!

---

### 03. 원칙의 함정

But 디미터 법칙이 절대적인 것은 아니다.

#### 디미터의 법칙은 하나의 도트. 를 규정하는 규칙이 아니다.

Java8에서 자주쓰이는 Stream, filter와 같은 메서드로 dot dot dot 이 쓰여도 디미터의 법칙을 위반하는 것은 아니다.

디미터의 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우에 한정한다.

#### 결합도와 응집도의 충돌

또한 무조건적으로 디미터의 법칙을 따라 위임 메서드를 사용하다가 오히려 응집도가 떨어지는 코드를 만들 수 있다.

캡슐화 위반을 해결하기위해서 위임 메서드를 만들고, 리팩토링하여 Tell don't ask 스타일을 준수하는 퍼블릭 인터페이스를 얻었다고 생각하지만

결과적으로 본질적 책임이 옮겨가면서 응집도를 낮추지만 결합도가 높아진다.

전체적 관점에서는 캡슐화 향상보다는 응집도를 높이고 결합도를 낮추는 것이 더 좋은 방벙이다.

그러니까 소프트웨어 공학에서 몇 없는 '경우에 따르라' 라는 법칙을 지켜서 안목을 길러 알아서 판단하는 것이 좋은 코드를 만드는 지름길 ^^

---

### 04. 명령-쿼리 분리 원칙

한 문장으로 표현하면 "질문이 답변을 수정해서는 안된다."
