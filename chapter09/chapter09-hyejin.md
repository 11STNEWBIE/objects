# 9. 유연한 설계  
- 유연하고 재사용 가능한 설계를 만들기 위해 적용할 수 있는 다양한 의존성 관리 기법들을 "원칙"이라는 관점에서 정리하기

## 01. 개방-폐쇄 원칙

- Open-Closed Principle (by Robert Martin)

> 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

- 확장에 대해 열려 있다
  - '동작'의 관점
  - 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가하여 애플리케이션의 기능을 확장
- 수정에 대해 닫혀 있다.
  - '코드'의 관점
  - 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있음

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

- 할인 정책의 경우
  - Movie는 추상 클래스 DiscountPolicy에 의존
  - 새로운 종류의 할인 정책을 추가하고 싶다면,
    - 기존에 Movie가 DiscountPolicy에 의존한 부분은 손대지 않고 (수정에 대해 닫혀 있다)
    - DiscountPolicy를 구현한 클래스*만*을 추가하여 구현이 가능하다. (확장에 대해 열려 있다)

### 추상화가 핵심이다

- 추상화
  - 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성 극복
  - 문맥이 바뀌더라도 변하지 않는 부분 (다양한 상황에서의 공통점) 만을 남겨야 한다.
  - 추상화를 통해 생략된 부분은 확장의 여지를 남긴다.
- 수정에 의한 영향을 최소화하기 위해 모든 요소가 추상화에 의존해야 한다.
  - 변경되지 않을 부분을 신중하게 결정하자

## 02. 생성 사용 분리

- 객체를 생성하는 부분을 어디에 둘 것인가?
  - 동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 있는 것은 좋지 않다
  - 즉, 생성과 사용을 분리 (seperation use from creation)
- 가장 보편적인 방법 : 객체를 생성할 책임을 클라이언트로 옮기기
  - Movie의 클라이언트가 적절한 DiscountPolicy 인스턴스를 생성한 후 Movie에게 전달하도록

### FACTORY 추가하기

- 하지만 클라이언트도 특정한 컨텍스트에 묶이지 않기를 바란다면
  - 자세히 보면 클라이언트도 객체 생성 & 사용을 다 하게 된다
  - 객체 생성에 특화된 FACTORY 추가 → 생성은 오직 FACTORY만
  - 이를 통해 클라이언트도 사용과 관련된 책임만 지게 된다

### 순수한 가공물에게 책임 할당하기

- 시스템을 객체로 분해하기 by Craig Larman
  - 표현적 분해 (representational decomposition)
    - 도메인 모델에 담겨 있는 개념과 관계를 따름
  - 행위적 분해 (behavioral decomposition)
    - 하지만 도메인만으로는 부족한 경우가 발생
    - 순수한 가공물 (pure fabrication) : 도메인과 무관한 인공적인 객체
      - 애플리케이션 내에서 이러한 객체들이 도메인 개념을 반영하는 객체들보다 더 많은 비중을 차지하는 것이 일반적
      - 도메인 개념이 만족스럽지 못하다면 주저하지 말고 인공적인 객체를 창조하라!
      - 대부분의 디자인 패턴은 이러한 객체들을 포함한다

## 03. 의존성 주입

- 생성자 주입 (객체를 생성하는 시점에 생성자를 통해서)
  - 객체의 생명주기 전체에 걸쳐 관계 유지
- setter 주입 (객체 생성 후 setter 메서드 사용)
  - 언제라도 의존 대상을 교체할 수 있음
- 메서드 주입 (메서드 실행 시 인자를 이용)
  - 주입된 의존성이 한두 개의 메서드에서만 사용된다면

### 숨겨진 의존성은 나쁘다

- SERVICE LOCATOR 패턴
  - 객체가 직접 service locator에게 의존성을 해결해 줄 것을 요청
  - 의존성은 암시적이며 코드 깊숙한 곳에 숨겨져 있다
    - 의존성과 관련된 문제가 컴파일타임이 아닌 런타임에 가서야 발견
    - 모든 단위 테스트 케이스에 걸쳐 ServiceLocator의 상태를 공유 (모든 단위 테스트는 서로 고립되어야 한다는 기본 원칙 위반)
- 가급적 의존성을 객체의 퍼블릭 인터페이스에 노출하라

## 04. 의존성 역전 원칙

- Dependency Inversion Principle (DIP) by Robert Martin
  - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
  - 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

### 의존성 역전 원칙과 패키지

- 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다.
  - Seperated Interface 패턴 (마틴 파울러)
    - 참고 도서) 엔터프라이즈 애플리케이션 구축을 위한 객체지향 설계의 원리와 기법

## 05. 유연성에 대한 조언

### 유연한 설계는 유연성이 필요할 때만 옳다

- 변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함의 미덕을 버리게 될 가능성이 높다
- 불필요한 유연성은 불필요한 복잡성을 낳음
- 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다

### 협력과 책임이 중요하다

- 객체를 생성할 책임을 담당할 객체나 객체 생성 메커니즘을 결정하는 시점은 책임 할당의 마지막 단계로 미뤄야 한다.
