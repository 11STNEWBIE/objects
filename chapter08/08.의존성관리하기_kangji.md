# CHATER 08. 의존성 관리하기

- 잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성되어 있음
- 작고 응집도 높은 객체란? 초점 명확하고 한 가지 일만 잘 하는 객체 → 단독으로 수행할 수 있는 작업 거의 없음 → 객체 사이의 협력을 통해 애플리케이션 기능 구현
- 협력은 객체가 다른 객체에 대해 알 것 강요함 → 객체 사이의 의존성 생김
- 협력 위해 의존성 필요하지만 과도하면 변경 어려움. 따라서 의존성 관리와 객체가 변화 받아들일 수 있도록 의존성 정리하는 기술 필요.

## 01. 의존성 이해하기

### 변경과 의존성

두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미. 따라서 의존성은 변경에 의한 영향의 전파 가능성을 암시함.

의존성의 의미는 실행 시점과 구현 시점에 서로 다른 의미 가짐

- **실행 시점**
    - 의존하는 객체가 정상적으로 동작하기 위해, 실행 시 의존 대상 객체가 반드시 존재해야 함
- **구현 시점**
    - 의존 대상 객체가 변경되면 의존하는 객체도 함께 변경됨

### 의존성 전이

A가 B에 의존하고, B가 C에 의존할 경우, A는 잠재적으로 C에 의존하게 됨 → **의존성 전이**

의존성은 전이될 수 있기 때문에 의존성을 다음 두 종류로 나누기도 함

- **직접 의존성(direct dependency)**
    - 한 요소가 다른 요소에 직접 의존하는 경우. (샘플에서는)코드에 명시적으로 드러남.
- **간접 의존성(indirect dependency)**
    - 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우. (샘플에서는)코드 안에 명시적으로 드러나지 않는다.

의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이기 때문에, 변경과 관련이 있는 어떤 것에도 의존성이라는 개념을 적용할 수 있다.

### 런타임 의존성과 컴파일타임 의존성

- **런타임**
    - 애플리케이션이 실행되는 시점
    - 객체를 중심으로 본다
- **컴파일타임**
    - 일반적으로, 작성된 코드를 컴파일 하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키기도 함
    - 컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 *작성한 코드의 구조*
    - 클래스를 중심으로 본다

유연하고 재사용 가능한 코드를 설계하기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행구조를 만들 수 있어야 하고, 따라서 두 종류의 의존성을 서로 다르게 만들어야 한다.

→ 클래스가 협력할 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어짐. 따라서 이 대신, 실제로 협력할 객체가 어떤 것인지는 런타임에 해결

### 컨텍스트 독립성

클래스가 사용될 즉정한 문맥 대한 최소한의 가정만 이루어 다른 문맥에서 재사용하기 좋은 것을 컨텍스트 독립성이라고 함(각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다는 의미).

### 의존성 해결하기

컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다. 이처럼 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 **의존성 해결**이라고 부르며, 보통 다음 세 가지 방법을 사용.

1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
    - 객체를 생성한 이후에도 의존한고 있는 대상을 변경할 수 있는 가능성 열어두고 싶을 때 유용
    - 장점: 설계가 더 유연해짐
    - 단점: 객체 생성 후 의존 대상 설정하기 때문에 그 전까지는 객체의 상태가 불완전할 수 있음 → 생성자 주입 방식과 혼합하여 사용 가능
3. 메서드 실행 시 인자를 이용해 의존성 해결
    - 협력 대상에 지속적으로 의존 관계 맺을 필요 없이 메서드가 실행되는 동안만 일시적으로 의존 관계가 있어도 되거나, 메서드가 실행될 때마다 의존 대상이 달라질 때 유용.

## 02. 유연한 설계

의존성을 관리하는 데 유용한 몇가지 원칙과 기법을 익혀봅시다

### 의존성과 결합도

- 느슨한 결합도(loose coupling) 또는 약한 결합도(weak coupling)
    - 어떤 두 요소 사이에 존재하는 의존성이 바람직할 때
- 단단한 결합도(tight coupling) 또는 강한 결합도(strong coupling)
    - 어떤 두 요소 사이에 존재하는 의존성이 바람직하지 않을 때

바람직한 의존성? 설계를 재사용하기 쉽게 만드는 의존성.

### 지식이 결합을 낳는다

더 많이 알수록 더 많이 결합된다(더 많이 알고 있음 → 더 적은 컨텍스트에서 재사용 가능).  따라서 결합도 느슨하게 만들기 위해 협력 대상에 대해 필요한 정보 외에는 최대한 감춰야 함. 추상화!

### 추상화에 의존하라
