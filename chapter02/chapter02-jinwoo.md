# 2장 객체지향 프로그래밍

# 1 영화 예매 시스템 (2장 예제 요구사항)

- 영화 : 영화 기본 정보
- 상영 : 관객들이 영화 관람하는 사건
- 할인 조건 : 한 영화당 다수 할인 조건이 존재할 수 있다
    - 순서 조건 ex> 10th 상영
    - 기간 조건 ex> start am 10 - end pm 1
- 할인 정책 :한 영화당 하나만 존재
    - 금액 할인 정책  ex> 1000원 할인
    - 비율 할인 정책 ex> 10% 할인

# 2 객체지향 프로그래밍을 향해

## 협력, 객체, 클래스 ***

진정한 객체지향 패러다임으로 전환하기 위해서는 **클래스가 아닌 객체에 초점**을 맞출 때 얻을 수 있다.

- 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라. 클래스는 공통적 상태와 행동을 공유하는 객체들을 추상화한 것으로, **어떤 객체들이 어떤 상태와 행동을 가지는지 먼저 결정**해야 한다.
- 객체를 독립적 존재가 아니라, 기능 구현을 위해 **협력하는 공동체의 일원**으로 봐야 한다.
- **훌륭한 협력 → 훌륭한 객체 → 훌륭한 클래스**

## 도메인의 구조를 따르는 프로그램 구조

도메인 : 문제를 해결하기 위해 프로그램을 사용하는 분야

요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다.

## 클래스 구현하기 ; 객체의 자율성 ***

클래스의 내부와 외부를 구분하는 것이 중요하다.

 —> 경계의 명확성이 객체의 자율성 보장 —> 프로그래머에게 구현의 자유를 제공한다

- 객체 내부를 통제하는 이유 : **객체를 자율적인 존재로** 만들기 위해서!
    - 그러기 위해 외부 간섭을 최소화해야 한다.
    - 외부에서는 객체가 어떤 상태, 어떤 생각을 하는지 알아서 안되며, 결정에 직접 개입하려 해서는 안된다!
- 일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야 한다.

## 협력하는 객체들의 공동체

객체지향 프로그램을 작성할 때는

1 먼저 협력의 관점에서 어떤 객체가 필요한지 결정하고

2 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성한다.

(훌륭한 협력 → 훌륭한 객체 → 훌륭한 클래스)

## 협력에 관한 짧은 이야기 ; 메시지 vs 메서드 ***

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송 뿐이다.

메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다.

이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라고 한다.

메시지와 메서드 구분에서부터 다형성의 개념이 출발한다.

# 3 할인 요금 구하기

코드 의존성 ≠ 실행 시간 의존성 !!

→ 클래스 사이 의존성 ≠ 객체 사이 의존성

- 다를수록 코드 이해는 어렵지만, 유연하고 확장 가능하다.

차이에 의한 프로그래밍(programming by difference): 부모 클래스와 다른 부분만을 추가해서 새로운 클래스 쉽고 빠르게 만드는 방법

# 4 상속과 다형성

## 상속과 인터페이스

상속 : 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있다.

- 업캐스팅 : 자식 클래스가 부모 클래스 대신하는 것

인터페이스 : 객체가 이해할 수 있는 메시지 목록 정의

## 다형성

다형성 : 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.

다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다.

# 5 추상화와 유연성

## 추상화의 힘 (장점)

- 요구사항의 정책을 높은 수준에서 서술할 수 있다.
- 추상화를 이용하면 설계가 좀 더 유연해진다.

Context Independency(컨텍스트 독립성)?!

## 코드 재사용 - 상속의 문제점은?

### 상속의 문제점

- 캡슐화를 위반한다
    - 부모 클래스 구현이 자식 클래스에게 노출된다.
- 설계가 유연하지 않다

### 상속보다 합성(composition)이 더 좋다

- 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
- 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.

### 그러면 상속은 쓰지마?

코드 재사용시 상속보다 합성을 선호하는 것이 옳지만, 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수밖에 없다.

---

# 깨달은 점 및 새로 알게된 점

1 좋은 설계를 위해서는 클래스가 아닌 객체를 먼저 봐야겠다. 협력을 위해 객체가 어떤 상태, 행동을 가져야하는지 먼저 분석해야겠다.

**훌륭한 협력 → 훌륭한 객체 → 훌륭한 클래스**

2 객체를 자율적으로 만들어야한다.

3 Compoistion over Inheritance 참고 글

[https://javacan.tistory.com/entry/Composition-over-Inheritance-에-대해-자칫-오해를-줄-수-있는-글](https://javacan.tistory.com/entry/Composition-over-Inheritance-%EC%97%90-%EB%8C%80%ED%95%B4-%EC%9E%90%EC%B9%AB-%EC%98%A4%ED%95%B4%EB%A5%BC-%EC%A4%84-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B8%80)