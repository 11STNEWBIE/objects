# 5장 - 책임 할당하기

# 5장 - 책임 할당하기

## Information expert 패턴 : 정보 전문가에게 책임을 할당하라

1. **메시지를 전송할 객체는 무엇을 원하는가?** : ex → 예매하라
2. **메시지를 수신할 적합한 객체는 누구인가?** : 정보 전문가 (자율적인 존재) → 정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있다. → 캡슐화 유지 → 응집력 상승 → 결합도 하락 → 유지보수 굿
    - **의문점** : 정보를 알고 있으려면 해당 객체에 데이터가 먼저 설계되어 있어야할 것 같은데, 이것은 앞장에서 단점을 주구장창 이야기 한 데이터 기반 개발이 되는게 아닌가? 우리가 지금 하는건 메시지 기반 개발인데 말이다.
        - **필자의 답** : 여기서 이야기하는 정보는 데이터와 다르다는 사실에 주의하라. 책임을 수행하는 객체가 정보를 '알고' 있다고 해서 그 정보를 '저장'하고 있을 필요는 없다. 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있다. 어떤 방식이건 정보 전문가가 데이터를 반드시 저장하고 있을 필요는 없다는 사실을 이해하는 것이 중요하다.
    - *예매하라* 와 가장 어울리는 객체는 '상영'이라는 도메인 개념이 적합할 것이다. 상영은 영화에 대한 정보와 상영 시간, 상영 순번처럼 영화 예매에 필요한 다양한 정보를 알고 있다.

> 설계는 트레이드 오프 활동이다. 따라서 위 패턴말고도 다른 책임 할당 패턴들을 함께 고려해야 할 필요가 있다. 높은 응집도와 낮은 결합도는 객체에 책임을 할당할 때 항상 고려해야 하는 기본 원리다.

## 높은 응집도와 낮은 결합도

### Low coupling 패턴

- 어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까? 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.
- 낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리다. 다시 말하면 평가원리. 여러 대안들이 있을 때는 낮은 결합도를 유지할 수 있는 설계를 선택해라.
1. 도메인 개념을 고려했을 때 누구와 협력하게 할지 결정하기 쉬워진다. → 결합도 하락시킬 수 있다

### High Cohesion 패턴

- 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가?
- 높은 응집도를 유지할 수 있게 책임을 할당하라
- 낮은 결합도처럼 높은 응집도 역시 모든 설계 결정에서 염두에 둬야 할 원리이다.
1. Screening 의 역할은 상영하는 것이다. 그런데 DiscountCondition 와 협력하게 되면 DiscountCondition 가 변경될 경우 Screening도 함께 변경되어야한다. → 응집도 하락
2. 반면 Movie 의 주된 책임은 영화 요금을 계산하는 것 (?)
    - 따라서 영화 요금을 계산하기 위해 DiscountCondition이 협력하는 것은 응집도에 아무런 해도 끼치지 않는다.

낮은 결합도와 높은 응집도 패턴은 설계를 진행하면서 책임과 협력의 품질을 검토하는 데 사용할 수 있는 중요한 평가 기준이다.

책임을 할당하고 코드를 작성하는 매순간마다 이 패턴들을 고려하며 설계 품질을 검토하면 단순하면서도 재사용 가능하고 유연한 설계를 얻을 수 있을 것이다.

## Creator 패턴 : 창조자에게 객체 생성 책임을 할당하라

영화 예매 협력의 최종 결과물 : Reservation 인스턴스 생성 → 누가 이 책임을 맡느냐?

Creator 패턴은 이 같은 경우에 사용할 수 있는 책임 할당 패턴으로서 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.

> 객체 A를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가? 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라

- B가 A 객체를 포함하거나 참조한다.
- B가 A 객체를 기록한다.
- B가 A 객체를 긴밀하게 사용한다.
- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (B는 A에 대한 정보 전문가)

이 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다. 생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다. 다시 말해서 두 객체는 서로 결합된다. 

이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다. 결과적으로 Creator 패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 한다.

- Reservation 에 대한 위 규칙을 가장 만족하는 것은 Screening 이다. 예매 정보를 생성하는 데에 필요한 정보들을 가지고 있다.

**스케치 끝.**

## 구현 및 개선

### DisCountCondition 개선하기

- 변경의 이유가 1가지 이상이다. 문제가 있다. (응집도 낮음) → 변경의 이유에 따라 클래스 분리
- 일반적으로 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋다. → 하지만 갓 입문한 개발자들은 클래스 안에서 변경의 이유를 찾는 것이 생각보다 어렵다.
    - 희망적인 소식 : 변경의 이유가 하나 이상인 클래스에는 몇가지 뚜렷한 패턴이 존재한다.
        - 1. 인스턴스 변수가 초기화 되는 시점을 살펴본다. → 응집도 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화 한다. 응집도가 낮으면 일부만 초기화하고 일부는 초기화 시키지 않는다.
        - 2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴본다. → 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다.
        - **응집도를 높이기 위한 방법** : 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.

### 클래스 응집도 판단하기

응집도가 낮다는 증거

- 클래스가 하나 이상의 이유로 변경돼야 한다. → 변경의 이유를 기준으로 클래스를 분리하라
- 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다. → 초기화되는 속성의 그룹을 기준으로 클래스 분리
- 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다. → 이들 그룹을 기준으로 클래스를 분리하라.

메서드의 크기가 너무 크면 이러한 문제들이 감춰지는 경우가 있으므로 메서드를 응집도 높은 작은 메서드로 분해해 나가면 숨겨져 있던 문제점이 명확하게 드러나는 경우가 많다.

### 개선작업

- 응집도를 개선하려고 클래스를 분리하니 나타나는 문제
    - 결합도가 상승. (날짜 컨디션, 연속된 값 컨디션)으로 분리했으니 양쪽 모두에게 결합됌
    - 새로운 할인  조건을 추가하기가 더 어려워졌다

    **결론** : 응집도가 높아졌지만 변경과 캡슐화라는 관점에서 전체 설계의 품질이 나빠졌다.

**HOW TO DO**

1. Polymorphism 패턴 : 다형성을 통해 분리하기
    - 역할을 사용하면 객체의 구체적인 타입을 추상화 할 수 있다. 협력하는 객체의 구체적인 타입을 몰라도 상관 없다.
    - 조건에 따른 변화는 프로그램의 기본 논리다. if나 switch 등의 조건 논리를 사용해서 설계한다면 새로운 변화가 일어난 경우 조건 논리를 수정해야 한다. 이것은 프로그램을 수정하기 어렵고 변경에 취약하게 만든다.
    - Polymorphism 패턴은 객체의 타입을 검사해서 타입에 따라 여러 대안들을 수행하는 조건적인 논리를 사용하지 말라고 경고한다. 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고한다.

    > 구현을 공유할 필요가 있으면 추상클래스, 책임만 동일한 것이면 인터페이스

2. Protected Variations 패턴 : 변경으로부터 보호하기
    - DiscountCondition 타입을 추가하더라도 Movie 는 영향을 받지 않는다. 인터페이스를 실체화하는 클래스를 추가하는 것으로 할인 조건의 종류를 확장할 수 있다.
    - 객체, 서브시스템, 그리고 시스템을 어떻게 설계해야 변화와 불안정성이 다른 요소에 나쁜 영향을 미치지 않도록 방지할 수 있을까? 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라. (변하는 개념을 캡슐화하라 GOF94)

### *도메인의 구조가 코드의 구조를 이끈다*

이번 장을 통해 만들어진 구조가 처음 시작할 때 소개했던 도메인 모델과 유사하다. 
→ 도메인 모델은 단순히 설계에 필요한 용어를 제공하는 것을 넘어 코드의 구조에도 영향을 미친다.

**중요 : 변경 역시 도메인 모델의 일부이다. 도메인 모델에는 도메인 안에서 변하는 개념과 이들 사이의 관계가 투영되어있어야 한다. (그림 5.7)** 
* 구현을 가이드할 수 있는 도메인 모델을 선택하라. *

**궁금한 점** : 보통 설계는 무언가를 처음 만들 때 주로 하는 것인데, 비슷한 서비스를 만들어보고 운영해본 입장이 아닌 이상 도메인 지식이 부족해서, 도메인의 구조가 코드의 구조를 이끌게 하는 것이 어려울 것 같다는 생각이 든다. 조영호님은 영화 예매 도메인만 가지고 오랜 기간동안 세미나를 해오셨기 때문에 이 도메인에 대해서 아주 전문가이실거다. 하지만 아예 모르는 분야에서 처음 접해도 이런 설계가 나올 수 있을까? 

→ 서비스에 대해 기획자, 개발자가 함께 고민을 한 결과를 도메인 베이스 지식으로 삼고 설계를 할 것 같다. 도메인이란 결국 유비쿼터스 언어로서 기획자나 개발자가 모두 이해할 수 있는 그런 지식이기 때문에 더더욱 도메인 기반으로 설계하는 것이 맞는 것 같다.

### *코드의 구조가 도메인의 구조에 대한 새로운 통찰력을 제공한다*

도메인 모델은 단순히 도메인의 개념과 관계를 모아 놓은 것이 아니다. 도메인 모델은 구현과 밀접한 관계를 맺어야 한다. 도메인 모델은 코드에 대한 가이드를 제공할 수 있어야 하며, 코드의 변화에 발맞춰 함께 변화해야 한다. 

**현실** : 코드의 구조가 위와 같은 형태로 잘 관리되지 못하면 도메인의 구조 또한 망쳐버리는 역효과를 발생시킨다. `ex →`  

`기획 : (서비스에서 당연히 필요한 내용 추가) 해야 합니다.` 

`개발 : 현재 코드로는 그렇게 하는건 불가능합니다.` 

그런 일들을 줄이기 위해 우리는 이런 책을 읽고 있는 것이다.

### 이번 장을 공부하고 나서 읽을만한 자료

[GRASP - General Responsibility Assignment Software Patterns Explained - Kamil Grzybek](http://www.kamilgrzybek.com/design/grasp-explained/?fbclid=IwAR2UiSqLVxagfi_239vLFYg7rs2RWHmcwedSfx_XYi97mZeVMy1t4O9ChLw)

[Spring: The art of using GRASP Patterns](https://javadepend.wordpress.com/2011/10/26/spring-the-art-of-using-grasp-patterns/?fbclid=IwAR3EnJwi0qd2lkHz01gd8iUduCv9L_o9ieOVNR7fPiUy4sZxMEp8ujfnRM0)

[A Short Overview of Object Oriented Software Design](https://www.freecodecamp.org/news/a-short-overview-of-object-oriented-software-design-c7aa0a622c83/?fbclid=IwAR3CKajYR240H6q2RoR-KCPlL-BHQuwX0c6AdIr_Nd6a2Grml6Bh54nryQM)

[](https://medium.com/@codesquad_yoda/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8%EC%99%80-grasp-%ED%8C%A8%ED%84%B4-d5e37a1bb5dc)