# CHAPTER 11. 합성과 유연한 설계

상속과 합성은 코드 재사용이라는 동일한 목적을 가진다는 점을 제외하면 구현부터 변경 방식까지 모든 면에서 차이를 보임

- 상속
    - is-a 관계
    - 부모 클래스 내부 구현 상세히 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도 높아짐
    - 화이트박스 재사용이라고 부르기도 함(부모 클래스 내부가 자식 클래스에 공개되기 때문에)

- 합성
    - has-a 관계
    - 내부에 포함되는 객체의 구현에 의존하지 않고 퍼블릭 인터페이스에 의존. 따라서 객체 내부 구현 변경되더라도 영향 최소화 가능
    - 블랙박스 재사용이라고 부르기도 함(객체 내부는  공개되지 않고 인터페이스를 통해서만 재사용되기 때문)

## 상속을 합성으로 변경하기

상속 관계에서 부모 클래스에 해당하는 클래스의 인스턴스 변수를 자식 클래스에 해당하는 클래스의 인스턴스 변수로 선언하는 방식으로 합성 관계로 변경해보자.

예. `Vector`를 상속받는 `Stack`을 합성 관계로 변경하면 아래와 같다

    public class Stack<E> {
    	private Vector<E> elements = new Vecotr<>();
    
    	public E push(E item) {
    		elements.addElement(item);
    		return item;
    	}
    
    	public E pop() {
    		if (elements.isEmpty()) {
    			throw new EmpthStackException();
    		}
    		return elements.remove(elements.size() - 1);
    	}
    }

기존의 상속 관계에서 발생하던 문제(임의의 위치에 요소를 추가하거나 삭제가 가능하다는, `Stack`의 규칙에서 벗어나는 상황) 가 발생하지 않음.즉 합성 관계로 변경함으로써 클라이언트가 `Stack`을 잘못 사용할 수도 있다느 가능성을 깔끔하게 제거한 것.

## 합성으로 인해 얻는 장점?

- 컴파일타임에 결정되는 상속관계와는 달리 합성은 런타임 관계로 변겸함으로써 코드를 실행하는 도중에 변경할 수 있음(합성은 구현이 아닌 퍼블릭 인트페이스에만 의존하기 때문에 런타임에 객체의 관계 변경 가능)
- 따라서 상속 관계로 인해 일어날 수 있는 클래스 폭발 문제를 해결 가능
- 컴파일타임 의존성과 런타임 의존성의 거리가 멀어질수록 설계의 복잡도 상승하기 때문에 코드 이해 어려워 지지만, 변경과 유지보수에 대한 장점 가짐
